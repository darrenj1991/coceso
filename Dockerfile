# This Dockerfile builds and runs a Spring Boot application from a multi-module maven project
# It takes two build arguments:
# - MODULE is the path to the Spring Boot module, relative to the base pom file (e.g. module1/submodule2)
# - APP is the name of the generated Spring Boot jar file, normally the artifact id of the maven module

# First stage: Build the source code with maven
# TODO alpine would be better, but is not available with OpenJDK 11 as of now
FROM maven:slim AS build
WORKDIR /app

# Copy all POM files
# All modules need to be included, even if they are not required for the build
# The list can be generated by running this from the directory with the base pom file:
# find -name pom.xml -printf "COPY %p %h/\n" | sort -t" " -k3 | column -t
COPY  ./pom.xml                       ./
COPY  ./api-gateway/pom.xml           ./api-gateway/
COPY  ./config/pom.xml                ./config/
COPY  ./config/config/pom.xml         ./config/config/
COPY  ./config/db/pom.xml             ./config/db/
COPY  ./config/web/pom.xml            ./config/web/
COPY  ./geocode/pom.xml               ./geocode/
COPY  ./geocode/geocode/pom.xml       ./geocode/geocode/
COPY  ./geocode/geocode-impl/pom.xml  ./geocode/geocode-impl/
COPY  ./main/pom.xml                  ./main/
COPY  ./main/db/pom.xml               ./main/db/
COPY  ./main/entity/pom.xml           ./main/entity/
COPY  ./main/service/pom.xml          ./main/service/
COPY  ./main/service-impl/pom.xml     ./main/service-impl/
COPY  ./main/taglib/pom.xml           ./main/taglib/
COPY  ./main/view/pom.xml             ./main/view/
COPY  ./plugin/pom.xml                ./plugin/
COPY  ./plugin/alarm-text/pom.xml     ./plugin/alarm-text/
COPY  ./plugin/geobroker/pom.xml      ./plugin/geobroker/
COPY  ./plugin/gmaps/pom.xml          ./plugin/gmaps/
COPY  ./plugin/niu/pom.xml            ./plugin/niu/
COPY  ./plugin/vcm-poi/pom.xml        ./plugin/vcm-poi/
COPY  ./plugin/vienna/pom.xml         ./plugin/vienna/
COPY  ./plugin/wflwr-poi/pom.xml      ./plugin/wflwr-poi/
COPY  ./radio/pom.xml                 ./radio/
COPY  ./radio/radio-api/pom.xml       ./radio/radio-api/
COPY  ./radio/radio-listener/pom.xml  ./radio/radio-listener/
COPY  ./stomp/pom.xml                 ./stomp/
COPY  ./stomp/replay-common/pom.xml   ./stomp/replay-common/
COPY  ./stomp/stomp-endpoint/pom.xml  ./stomp/stomp-endpoint/
COPY  ./stomp/stomp-service/pom.xml   ./stomp/stomp-service/

# Resolve all dependencies, don't fail on missing (internal) dependencies
#RUN mvn -fn -B dependency:go-offline > /dev/null

# TODO Only pull dependencies of updated components for now
RUN mvn -fn -B dependency:go-offline -pl api-gateway,radio/radio-listener,stomp/stomp-endpoint -am > /dev/null

# Specify the required module
ARG MODULE

# Copy full source code (generated code is ignored through .dockerignore)
# TODO This causes the layer to be rebuilt with every code change in any module, even non-relevant ones. Only copy required modules?
COPY ./ ./

# Build the requested module and dependencies
RUN mvn -q package -pl ${MODULE} -am

# Second stage: Build the server image (needs only JRE)
# TODO alpine would be better, but is not available with OpenJDK 11 as of now
FROM openjdk:jre-slim AS runtime

# Run as non-root
# TODO Make this work with mounted volumes
#RUN adduser --system --group spring
#USER spring

# Volume for Spring Boot to write to
VOLUME /tmp

# Volumes where the config and log directories are mounted
VOLUME /config
VOLUME /log

# The arguments have to be declared again
ARG MODULE
ARG APP
ARG INSTALL

# TODO This is kind of an ugly hack...
RUN if [ -n "$INSTALL" ]; then apt-get update && apt-get install $INSTALL; fi

# Run the Spring Boot application
COPY --from=build /app/${MODULE}/target/${APP}-*.jar /app/app.jar
ENTRYPOINT ["java", "-Dspring.config.location=file:/config/", "-jar", "/app/app.jar"]
